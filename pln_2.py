# -*- coding: utf-8 -*-
"""PLN 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZpaqNIySusQt6LNc3JBm85vzmPFkTwq3

# Classificação de textos - Análise de Sentimentos
## Processamento de Linguagem Natural
Nesta aula continuaremos trabalhando com Classificação de textos, porém agora focaremos em uma tarefa específica, chamada de **Análise de Sentimentos**. 

O objetivo é que ao final desta aula você:
1. Entenda o que é a **Análise de Sentimentos**
2. Saiba treinar um classificador supervisionado para realizar análise de sentimentos usando um corpus anotado
3. Aprenda a utilizar a biblioteca Polyglot do Python que já possui métodos para identificar polaridade de textos em português
4. Acesse API do Twitter para obter dados em tempo real de redes sociais

### **O que é a Análise de Sentimentos?**

É a interpretação e classificação de emoções relativas a um texto, sendo estas emoções explícitas declaradas no texto ou implícitas.

![Análise de sentimentos. Fonte: https://monkeylearn.com/sentiment-analysis/](https://docs.google.com/uc?export=download&id=1okG1oHXPhnZiBBTtpZG4b3VdaWovCndT)

É uma tarefa de PLN/Machine Learning que permite empresas identificarem os sentimentos dos consumidores em relação a produtos, marcas ou serviços, através de opiniões deixadas em redes sociais ou em canais de comunicação da empresa.

### **Como treinar um classificador para realizar a Análise de Sentimentos?**
Iremos desenvolver nosso classificador, utilizando uma abordagem supervisionada, ou seja, precisaremos de dados rotulados com suas respectivas emoções.

O pipeline de execução é muito similar aos exemplos de classificação realizados na última semana, o que muda efetivamente são as classes/categorias envolvidas.

#### Dados
Para este exemplo iremos trabalhar com uma [base de dados de notícias](https://www.aclweb.org/anthology/W15-5616.pdf), rotulada com as emoções básicas de [Ekman](https://www.tandfonline.com/doi/abs/10.1080/02699939208411068): **alegria**, **tristeza**, **raiva**, **medo**, **repugnância** e **surpresa**. Em caso de ausência de emoção, a categoria **neutro** foi aplicada.



> **IMPORTANTE**: Faça o upload da base de dados para seu ambiente Google Colab ou Jupyter Notebook! Segue o [link](https://drive.google.com/file/d/12-mbbvHtnDVRTbQnhmOfnIXppbQ0hoyn/view?usp=sharing) para acesso.

#### Fluxo de execução
Vamos seguir o seguinte fluxo de processamento dos dados:


1.   Abrir o corpus
2.   Remover as stop-words
3.   Aplicar stemmer
4.   Gerar o Bag of Words
5.   Treinar o modelo SVM
6.   Predizer/Avaliar o modelo
"""

import pandas as pd
from numpy import True_

f = open("/content/analise-sentimentos-2000-noticias.txt", "r", encoding="utf-8-sig")
linhas = f.readlines()

corpus_textos = []
rotulo = []

# Percorre as 2000 linhas
for linha in linhas:

  # Separa texto e rótulo/categoria/emoção
  item = linha.split(";;")
  if item[0] != 'surpresa':
    rotulo.append(item[0])
    corpus_textos.append(item[1])
    
    df = pd.Series(rotulo)
        
    rotulo2 = df.replace(['alegria','tristeza','raiva', 'medo', 'desgosto', 'surpresa'],['positivo', 'negativo','negativo', 'negativo', 'negativo', ''])

    corpus_rotulos = rotulo2

from google.colab import drive
drive.mount('/content/drive')

#Comparando o tamanho dos corpus após edição do arquivo. 

tamanho_rotulos = len(corpus_rotulos)
print('Esse é o tamanho do corpus de rótulos: ', tamanho_rotulos)
tamanho_textos = len(corpus_textos)
print('Esse é o tamanho do corpus de textos: ', tamanho_rotulos)

# 5 primeiros textos
corpus_textos[0:10]

# 5 primeiros rótulos
corpus_rotulos[0:10]

"""Em nossos exemplos de classificação anteriores, separamos parte do banco de dados para **TREINAMENTO** e outra parte para **TESTE**, nesse tipo de avaliação que chamamos de **hold-out**.

Existem outras formas de realizar a avaliação, inclusive mais indicadas de acordo com a situação, mas isto não está no escopo de nossa disciplina, caso queira saber mais métodos de avaliação como o **cross-validation**, leia [este post](https://medium.com/@eijaz/holdout-vs-cross-validation-in-machine-learning-7637112d3f8f).
"""

from sklearn.model_selection import train_test_split

# O próprio sklearn tem um método para dividir a base de dados em treinamento e teste
# Neste caso estamos deixando 90% para treinamento e 10% para testes

corpus_treinamento, corpus_teste, rotulos_treinamento, rotulos_teste = train_test_split(corpus_textos, corpus_rotulos, test_size=0.10, random_state=1)

tamanhoTextoTreinamento = len(corpus_treinamento)
print('Esse é o tamanho do corpus de texto para treinamento: ', tamanhoTextoTreinamento)
tamanhoRotuloTreinamento = len(rotulos_treinamento)
print('Esse é o tamanho do corpus de rótulos para treinamento: ', tamanhoRotuloTreinamento)
tamanhoTextoTeste = len(corpus_teste)
print('\nEsse é o tamanho do corpus de textos para teste: ', tamanhoTextoTeste)
tamanhoRotulosTeste = len(rotulos_teste)
print('Esse é o tamanho do corpus de rótulos para teste: ', tamanhoRotulosTeste)

"""Vamos deixar preparada uma função para pré-processar os textos, utilizando uma lista de stop-words com novos itens, o stemming e normalização dos textos."""

import nltk
from nltk import tokenize
nltk.download('stopwords')
nltk.download('rslp')
nltk.download('punkt')

stopwords = nltk.corpus.stopwords.words('portuguese') #carrega stopwords da lingua portuguesa disponíveis no NLTK
stopwords += (',','.','(',')','"',"'",'´','`','!','$','%','&','...','-',':',';','?','``','\'\'') #acrescenta simbolos
stopwords += ('a','e','i','o','u','A','E','I','O','U') #acrescenta também vogais

stemmer = nltk.stem.RSLPStemmer()

def my_preprocessor(text):
    
    # Faz a remoção de tudo que não seja letra (essa adição é resposta ao exercício número 3) 
    text.replace("[^a-zA-Z#]", " ")
    
    # Normaliza para minúsculas
    text=text.lower()
    
    # Tokeniza
    words = tokenize.word_tokenize(text, language='portuguese')
    # Remove stop-words
    words_no_stopwords = [word for word in words if not word in stopwords]
    # Aplica stemming
    stemmed_words=[stemmer.stem(word=word) for word in words_no_stopwords]
    return ' '.join(stemmed_words)

"""Agora vamos extrair os atributos do texto (gerar a representação vetorial - bag of words) e criar nosso pipeline de classificação usando o classificador SVM."""

from sklearn.pipeline import Pipeline
from sklearn.svm import SVC
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer

# Primeiro aplica o BoW, depois envia dados ao classificador SVM
# (SEM retirada de stop-words e stemming)
#sent_clf = Pipeline([('vect', CountVectorizer()),('clf', SVC(kernel='linear', C=1))])

# Depois de executar uma vez, verifique os resultados e compare-os depois de descomentar a linha abaixo, onde retiramos as stop-words e aplicamos stemming
# (COM retirada de stop-words e stemming)

# Em resposta ao exercício número 2: foi adicionado a remoção de acentos e "ngram_range". Para o classificador, foi 
sent_clf = Pipeline([('vect', CountVectorizer(strip_accents ='unicode', ngram_range=(1,2), preprocessor = my_preprocessor)),('clf', SVC(kernel='linear', C=1, probability=True))])

from sklearn.pipeline import Pipeline
from sklearn.naive_bayes import MultinomialNB

#Essa é a resposta ao exercício 4, onde pede-se que seja testado com outro modelo de classificação. Neste caso, Naive Bayes.
sent_clf2 = Pipeline([('vect', CountVectorizer(strip_accents ='unicode', ngram_range=(1,2), preprocessor = my_preprocessor)), ('clf', MultinomialNB(alpha=0.0))])

# Inicia treinamento 
sent_clf = sent_clf.fit(corpus_treinamento, rotulos_treinamento)

# Inicia treinamento do modelo editado (clf2)
sent_clf2 = sent_clf2.fit(corpus_treinamento, rotulos_treinamento)

"""Já temos nosso modelo treinado! Agora vamos predizer a base de teste e avaliar os resultados."""

# Prediz base de teste
rotulos_preditos = sent_clf.predict(corpus_teste)

# Prediz base de teste para o modelo editado
rotulos_preditos = sent_clf2.predict(corpus_teste)

#Apresenta o resultado de acuracidade do modelo original (SVM)

from sklearn.metrics import accuracy_score
rotulos_preditos = sent_clf.predict(corpus_teste)
print("Acurácia do modelo original: ",accuracy_score(rotulos_preditos, rotulos_teste))

#Apresenta o resultado de acuracidade do modelo editado (Naive Bayes)

from sklearn.metrics import accuracy_score
rotulos_preditos = sent_clf2.predict(corpus_teste)
print("Acurácia do modelo editado: ",accuracy_score(rotulos_preditos, rotulos_teste))

from sklearn.metrics import classification_report

# Mostra relatório completo de avaliação
print(classification_report(rotulos_teste, rotulos_preditos))

"""**Modelo original do exercício**

              precision    recall  f1-score   support

     alegria       0.00      0.00      0.00        19
    desgosto       0.44      0.26      0.33        27
        medo       0.32      0.39      0.35        18
      neutro       0.52      0.73      0.61        51
       raiva       0.29      0.29      0.29         7
    surpresa       0.42      0.47      0.44        32
    tristeza       0.66      0.59      0.62        46

    accuracy                           0.48       200
   macro avg       0.38      0.39      0.38       200
weighted avg       0.45      0.47      0.45       200

"""

# Commented out IPython magic to ensure Python compatibility.
from sklearn.metrics import confusion_matrix

# Podemos imprimir a matriz de confusão para tentar entender melhor os resultados
mat = confusion_matrix(rotulos_teste, rotulos_preditos)

# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns; sns.set()

rotulos_nomes = ['positivo', 'neutro', 'negativo']

fig, ax = plt.subplots(figsize=(10,10)) 
sns.heatmap(mat.T, square=True, annot=True, fmt='d', cbar=False, xticklabels=rotulos_nomes, yticklabels=rotulos_nomes )

"""**Modelo original do exercício**




![image.png](data:image/png;base64,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LTo1b4tPIQABCEAAAroWKOW3PfWQK1euJITcunVLvabcU1oIITY2Nur2IpFIvYwFCEAAAhCAgMEFNJU9LU5pMTc3T0tLU92oJSIiwtLS0uAZIgAIQAACEICAWkBT2VM1evv2bWpqat26dW1ty38IyNy5cydPnpyUlDRu3LjXr1//+OOP6pGwAAEIQAACEDC4gKay9+7du//9739//vln9erVMzMzHR0dN27cWKdOHQ1Bt2vX7uDBgw8eFD4+o3379hoeVKShE3wEAQhAAAIQ0JGAplNali1b5uDgcO/evZs3b967d69ly5bl3pOTEGJpaeni4uLs7GxkZJSXl6ejuNEtBCAAAQhAQAsBTUd7f/zxx+bNm42MCp/vZWZmNn/+fFdXV81jXL58edWqVX///TcpfMy1siKnwGjuEJ9CAAIQgAAEKBTQVPaqVav24sULBwcH1XgvX74s90vLgICAwMBAJycnPl/TcSSFCaArCEAAAhCAQMUFNJW9SZMmjR8/fvjw4fXq1Xv79u2pU6dmzZqluetq1ap16NBBcxt8CgEIQAACEDCUgKayN2LEiIYNG54/f/7p06e1a9fesGGDi4uL5kD79u175MiRQYMGGRsbq1qamppq3gSfQgACEIAABPQm8J8HLFR9VPU3oqpHN1Twtz08eKjq8rTqAQ8eotV0VD0YPHio6oa06gEPHipzOjZv3lzsM5FIVLduXVdX11q1ahX7SPVWiyvcS+0HKyEAAQhAAAK6ENB04snr16/37NkTERHx5s2biIiIPXv2xMbGHj161MPD48aNG7qIBn1CAAIQgAAEdCqg6bc9hUKxadOmvn37qiIIDQ09f/78r7/+GhwcvGHDBjc3N51Ghs4hAAEIQAAClAtoOtq7efNm79691UP26tVLdZA3ZMiQxMRE9XosQAACEIAABJgioKnsffLJJ0ePHlVnEhQU9MknnxBCMjIycH6mmgULEIAABCDAIAFNX3KuWrVqxowZe/bsqVOnTmpqqkAg2Lp1KyHk1atX5V7AxyAChAoBCEAAAtwR0FT2WrduHRIS8ujRo3fv3tnY2Dg5OaluVNb544s7RsgUAhCAAARYI6DpS86iSXbu3Fkqlebm5hZdiWUIQAACEIAAswQ0He09ffr0m2++EYlEqampgwYNioyMDA4ODgwMZFaGiBYCEIAABCCgFtB0tLds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)

> **CONCLUSÃO**: Apesar de verificarmos melhoria ao pré-processarmos o texto, os resultados ainda são regulares.

# **Detalhamento da s atividades realizadas.**


1. **Atividade 1:** Criamos um script que ignorava as linhas que continham "surpresa" e então realizamos a mudanças dos labels das emoções através de um "replace".
2. **Atividade 2:** Para o exercício 2, adicionamos dois novos atributos: "strip_accents" para remoção da acentuação, mas sem mudanças de acuracidade; e "n_gram(1,2)", que melhorou um pouco a acuracidade do modelo. Já para o classificador, no original tentei mudar o kernel para "sigmoid" mas houve a piora da acuracidade em 0.03% (de 0.8 para 0.77) e então foi removido e voltei ao original, além da mudança do kernel, tentei a adição do atributo "probability", que não mudou a acuracidade e foi mantido.
3. **Atividade 3:** A troca do para TfidfVectorizer na realidade apresentou queda na acuracidade de predição das emoções, e então mantive o "countvectorize", mas adicionei na etapa de pré-processamento a remoção de tudo que não era letra (text.replace("[^a-zA-Z#]", " ")), embora isso não tenha apresentado melhorias significativas no modelo. 
4. **Atividade 4:** Utilizamos o classificador Naive Bayes. Testamos com outros classificadores também, que embora nenhum tenha chego na acuracidade do modelo original (SVC -> 0.8), o Naive Bayes apresentou acuracidade de 0.77. Alguns dos demais testes: RandomForest -> 0.71, SGD -> 0.77 e KNeighborsClassifier -> 0.6.

#### **Atividade Somativa 2 - Como podemos tentar melhorar os resultados?**

**1) Redução da granularidade dos sentimentos**
Como podemos ver na matriz de confusão o classificador tem vários pontos de erro, em todas emoções. E se modificarmos o corpus para ao invés de 7 emoções, trabalhar com as 3 clássicas (positivo, neutro, negativo)?

Vamos então adotar a seguinte sistemática de atualização da base de dados:

A classe "**positivo**" será obtida utilizando-se as instâncias da base original rotuladas como "alegria". 

A classe "**negativo**" será obtida utilizando-se as instâncias rotuladas como "raiva", "medo", "desgosto" e "tristeza". 

Já a classe "**neutro**", utilizará as instâncias da base original rotuladas como "neutro". 

As instâncias rotuladas como "surpresa" não serão utilizadas.

Crie um novo arquivo para esta base de dados atualizada, carregue-o em nosso notebook e compare os resultados.

**2) Configuração dos parâmetros de extração de atributos e do classificador**
Altere a configuração de pelo menos um atributo gerado pela vetorização das palavras (i.e., CountVectorizer) e também pelo classificador utilizado.

**3) Adicione novas etapas de extração de atributos ou de pré-processamento**
Incorpore ao menos uma nova etapa de pré-processamento ou extração de atributos (e.g., TF-IDF) ao pipeline atual.

**4) Utilize outro classificador de texto**
Treine ao menos um novo modelo utilizando um classificador de textos diferentes. Ele pode pertencer à biblbioteca sklearn ou qualquer outra.

### **Existe alguma ferramenta pronta que realize análise de sentimentos?**
Não é sempre que teremos um corpus anotado para utilizar em nossas tarefas, neste caso, existem bibliotecas que incorporam funcionalidades simples que podem ser usadas para detectar a polaridade de textos (negativo, positivo).

No caso da língua portuguesa, a [Polyglot](https://polyglot.readthedocs.io/en/latest/index.html) tem um léxico de polaridade das palavras, que pode ser usado para detecção simples de sentimentos.
"""

# Ela tem algumas dependências que devem ser instaladas
!pip install -U git+https://github.com/aboSamoor/polyglot.git@master

import polyglot
from polyglot.text import Text
# Baixa o léxicos da lingua portuguesa
!polyglot download LANG:pt

text = Text("O filme que vimos é realmente muito bom!")
print("{:<16}{}".format("Word", "Polarity")+"\n"+"-"*30)
for w in text.words:
    print("{:<16}{:>2}".format(w, w.polarity))

text = Text("As notas foram ruins.")
print("{:<16}{}".format("Word", "Polarity")+"\n"+"-"*30)
for w in text.words:
    print("{:<16}{:>2}".format(w, w.polarity))

text = Text("Não sei o que pensar.")
print("{:<16}{}".format("Word", "Polarity")+"\n"+"-"*30)
for w in text.words:
    print("{:<16}{:>2}".format(w, w.polarity))

"""### **Como obter dados em tempo real de redes sociais?**
Já vimos na disciplina que é possível utilizar o web-scraping para obter páginas da web e percorrer a estrutura HTML em busca das informações. Porém, em alguns casos temos opções mais rápidas e viáveis para recolher dados. Alguns sites oferecem o serviço de [API](https://canaltech.com.br/software/o-que-e-api/) para acesso aos dados, onde podemos autenticar e utilizar funções para buscar dados em tempo real.

Em nosso exemplo, utilizaremos a [API do Twitter](https://developer.twitter.com/en/docs) para buscar tweets sobre determinado assunto.

Neste exemplo, utilizaremos as chaves de acesso da conta do professor, mas quando você for desenvolver seu script, você deve criar seu próprio token de acesso. Basta acessar sua conta no Twitter, na [página do desenvolvedor](https://developer.twitter.com/en/docs) você deve ir em Apps > Create an app.

"""

import tweepy 
from tweepy import OAuthHandler 

# As chaves e tokens que você receberá ao criar um App
consumer_key = 'iUpbJiOv2LGFZdRTSqOOFndf7'
consumer_secret = 'AVQQS4UcSI6dlRkwO3PdrNo6Iuwl9k5yE4oae18yNvACnhREzs'
access_token = '12948382-GTwHQSlj2ylAsMxsm2TT8ecYQ8fUteAfNGTqJutAP'
access_token_secret = 'U1HOAmQWkSwfiGEacEqDL59QZ8dvpBhG03yiusjyhtI2M'

api = None
try: 
  # Cria um objeto de autenticação (OAuthHandler) 
  auth = OAuthHandler(consumer_key, consumer_secret) 
  # Define o token e senha de acesso
  auth.set_access_token(access_token, access_token_secret) 
  # Cria um novo objeto API para acessar os tweets 
  api = tweepy.API(auth) 
except: 
  print("Erro: Falha de autenticação no Twitter")

"""Uma vez que temos um objeto API autenticado, podemos fazer nossas buscas. A API oferecer vários métodos e parâmetros para buscar dados, basta olhar na [documentação da biblioteca tweepy](http://docs.tweepy.org/en/v3.5.0/api.html). Nós iremos utilizar o método **search()**, que funciona de maneira similar a própria caixa de busca no site do Twitter."""

try: 

  # Busca até 200 tweets utilizando a query informada
  tweets = api.search(q = 'Bolsonaro', count = 200) 

except tweepy.TweepError as e: 
  print("Erro : " + str(e))

"""> **DICA**: Estamos colocando todos trechos do processo entre [blocos try/except](https://docs.python.org/pt-br/3.8/tutorial/errors.html), assim em caso de erro, temos certeza de qual ponto do processo está com problemas.

Vamos fazer uma função que através da pontuação de polaridade das palavras do tweet, obtido através do léxico do polyglot, calculamos a polaridade do texto. Utilizaremos uma fórmula bem simples, onde somaremos todas polaridades, se o resultado por positivo o sentimento é positivo, se for zero é neutro, caso menor que zero, negativo.
"""

# Você pode fazer download dos léxicos de sentimento de cada idioma separadamente
!polyglot download sentiment2.en
!polyglot download sentiment2.tr
!polyglot download sentiment2.es
!polyglot download sentiment2.tk
!polyglot download sentiment2.fi
!polyglot download sentiment2.pt
!polyglot download sentiment2.de
!polyglot download sentiment2.it
!polyglot download sentiment2.lv
!polyglot download sentiment2.ca
!polyglot download sentiment2.la

qtdeTweetsPos = 0
qtdeTweetsNeg = 0
qtdeTweetsNeu = 0
tweets_str_list = []

# Percorre os tweets encontrados
for tweet in tweets: 

  #ATENÇÃO: Tenha certeza que já instalou e importou o polyglot acima!
  text = Text(tweet.text)

  somaP = 0
  
  # Percorre as palavras do tweet
  for palavra in text.words:
    # Soma polaridade da palavra
    somaP += palavra.polarity

  # Faz contagem das polaridades
  if somaP > 0:
    qtdeTweetsPos += 1
  elif somaP < 0:
    qtdeTweetsNeg += 1
  else:
    qtdeTweetsNeu += 1
                               
  # Imprime o tweet
  print("Polaridade: " + str(somaP) + " >>> " + tweet.text + "\n")

  tweets_str_list.append(tweet.text)

"""> **ATENÇÃO:** As vezes, o polyglot pode identificar de maneira errada o idioma do tweet, e neste caso tentará utilizar um recurso léxico que ainda não foi baixado. Você pode corrigir de duas maneiras, ou usa o try/except e ignora este tweet, ou baixa o léxico dos idiomas envolvidos e deixa que ele calcule de maneira errada mesmo."""

# Agora calculamos as porcentagens
print("POSITIVOS: {}%".format(100*qtdeTweetsPos/len(tweets))) 
print("NEGATIVOS: {}%".format(100*qtdeTweetsNeg/len(tweets))) 
print("NEUTROS: {}%".format(100*qtdeTweetsNeu/len(tweets)))

import matplotlib.pyplot as plt

# Podemos plotar um gráfico também
fig=plt.figure(figsize=(6,6))
plt.pie([qtdeTweetsPos, qtdeTweetsNeg, qtdeTweetsNeu],labels=['Positivo', 'Negativo', 'Neutro'],colors=['green', 'red', 'blue'])
plt.ylabel('')
plt.title('Polaridade',fontsize='18')
plt.show()

"""Poderíamos também construir uma WordCloud para entender melhor quais as palavras que estão mais associadas ao tema buscado.

Para isso iremos remover as stop-words e chamar uma função de WordCloud.
"""

import nltk
nltk.download('stopwords')
import matplotlib.pyplot as plt
from wordcloud import WordCloud

stopword= nltk.corpus.stopwords.words('portuguese')

# Retiramos ocorrências de links e retweets       
stopword.append('https')
stopword.append('RT')
stopword.append('co')
    
# Cria uma única string com todos tweets
str_tweets = " ".join(tweets_str_list)
    
# Gera a wordcloud
wordcloud = WordCloud(max_words=2000, max_font_size=90, stopwords=stopword, height=400, width=800).generate(str_tweets)

fig = plt.figure(figsize=[20,10])
plt.imshow(wordcloud, interpolation="bilinear")
plt.axis("off")
plt.title('WordCloud Twitter', fontsize='18')
plt.show()

"""#### Considerações finais
Aqui utilizamos uma abordagem BEM simples, baseada em um léxico de polaridade da biblioteca polyglot. Os textos provindos de redes sociais são muito difíceis de processar, o ideal seria uma abordagem mais complexa, de preferência com aprendizado supervisionado, capaz de lidar com algumas características e desafios destes textos:
- Uso de gírias
- Ausência de regras ortográficas
- Uso de símbolos (emojis, hashtags)
- Presença de ironia
- Uso de hiperlinks
- entre outros

#### **Atividade complementar**
Você pode deixar o algoritmo mais robusto, ao treinar um classificador utilizando as bases rotuladas de tweets em português, listadas nas referências deste notebook.

## Referências e Material complementar

* [Portuguese Tweets for Sentiment Analysis - Corpus anotado](https://www.kaggle.com/augustop/portuguese-tweets-for-sentiment-analysis)
* [Portuguese Tweets for Sentiment Analysis using nltk and sklearn](https://www.kaggle.com/leonardoassis/portuguese-tweets-nltk-and-sklearn)
* [tweetSentBR - Corpus anotado](https://bitbucket.org/HBrum/tweetsentbr/src/master/)
* [Anotando um Corpus de Notícias para a Análise de Sentimento: um Relato de Experiência](https://www.aclweb.org/anthology/W15-5616.pdf)
* [Twitter Sentiment Analysis using NLTK, Python](https://towardsdatascience.com/twitter-sentiment-analysis-classification-using-nltk-python-fa912578614c)
* [Creating The Twitter Sentiment Analysis Program in Python with Naive Bayes Classification](https://towardsdatascience.com/creating-the-twitter-sentiment-analysis-program-in-python-with-naive-bayes-classification-672e5589a7ed)
* [Sentiment Analysis with Python (Part 1) - Classifying IMDb Movie Reviews](https://towardsdatascience.com/sentiment-analysis-with-python-part-1-5ce197074184)
* [Twitter Developer API](https://developer.twitter.com/en/docs)
* [Sentiment Classification using Word Embeddings (Word2Vec)](https://medium.com/swlh/sentiment-classification-using-word-embeddings-word2vec-aedf28fbb8ca)
* [Sentiment Analysis on Tweets in Portuguese - Transformer and BERT](https://www.kaggle.com/viniciuscleves/sentiment-analysis-on-tweets-in-portuguese)

Esta aula foi inspirada no trabalho do [Prof. Emerson Cabrera Paraiso](http://lattes.cnpq.br/3493899263715892), a quem agradecemos pela permissão de uso de sua [base de dados](https://www.aclweb.org/anthology/W15-5616.pdf).

Este notebook foi produzido por Prof. [Lucas Oliveira](http://lattes.cnpq.br/3611246009892500).
"""